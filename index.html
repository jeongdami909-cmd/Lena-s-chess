<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>프로 마스터 AI 체스 - v34</title>
    <style>
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; background-color: #fcf9f2; }
        body { display: flex; flex-direction: column; align-items: center; font-family: -apple-system, sans-serif; padding: env(safe-area-inset-top) 10px env(safe-area-inset-bottom) 10px; }
        .app-wrapper { width: 100%; max-width: 400px; height: 100%; display: flex; flex-direction: column; justify-content: space-evenly; }
        #board { display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); width: 100%; aspect-ratio: 1 / 1; border: 4px solid #3d2b1f; background-color: #3d2b1f; box-shadow: 0 5px 15px rgba(0,0,0,0.2); position: relative; }
        .square { display: flex; justify-content: center; align-items: center; font-size: 8vw; cursor: pointer; user-select: none; }
        @media (min-width: 400px) { .square { font-size: 36px; } }
        .light { background-color: #fceecf; } .dark { background-color: #b58863; }
        .selected { background-color: #7b9a58 !important; }
        .pending { background-color: #e5c158 !important; }
        .origin { background-color: #d4a76a !important; opacity: 0.8; }
        .check { background-color: #f44336 !important; border-radius: 50%; }
        .black-piece { color: #000; font-weight: bold; }
        .white-piece { color: #fff; text-shadow: 1px 1px 2px #000; font-weight: bold; }
        .ui-row { display: flex; gap: 5px; width: 100%; }
        .captured-area { width: 100%; height: 35px; display: flex; align-items: center; gap: 5px; padding: 0 10px; background: rgba(0,0,0,0.05); border-radius: 8px; font-size: 11px; }
        button { flex: 1; padding: 12px 0; font-size: 14px; font-weight: bold; border: none; border-radius: 12px; cursor: pointer; color: white; }
        #btn-confirm { background-color: #4CAF50; display: none; }
        #btn-cancel { background-color: #f44336; display: none; }
        #btn-reset { background-color: #9e9e9e; }
        #status { font-size: 15px; font-weight: bold; color: #3d2b1f; text-align: center; min-height: 1.2em; }
        #ai-loader { display: none; width: 100%; height: 4px; background: #ddd; overflow: hidden; }
        .thinking-bar { width: 40%; height: 100%; background: #2980b9; animation: move 0.8s infinite linear; }
        @keyframes move { from { margin-left: -40%; } to { margin-left: 100%; } }
        
        /* 프로모션 팝업 */
        #promotion-overlay { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.7); z-index: 100; justify-content: center; align-items: center; gap: 10px; }
        .promo-choice { width: 60px; height: 60px; background: white; border-radius: 8px; display: flex; justify-content: center; align-items: center; font-size: 40px; cursor: pointer; }
    </style>
</head>
<body>
    <div class="app-wrapper">
        <div id="status">V34: 캐슬링 & 프로모션 업데이트</div>
        <div id="ai-loader"><div class="thinking-bar"></div></div>
        <div class="captured-area" id="black-captured"></div>
        <div id="board">
            <div id="promotion-overlay"></div>
        </div>
        <div class="captured-area" id="white-captured"></div>
        <div class="ui-row">
            <button id="btn-reset" onclick="resetGame()">새 게임 (초기화)</button>
        </div>
        <div class="ui-row">
            <button id="btn-cancel" onclick="cancelMove()">취소</button>
            <button id="btn-confirm" onclick="confirmMove()">이동 확정</button>
        </div>
    </div>

    <script>
        // AI 워커 코드 (프로모션/캐슬링의 복잡한 로직은 단순화하여 유지)
        const workerCode = `
            self.onmessage = function(e) {
                const { boardState, depth } = e.data;
                const isWhite = p => p && p === p.toUpperCase();
                const isBlack = p => p && p === p.toLowerCase();
                const pieceValues = { p: 100, n: 320, b: 330, r: 500, q: 900, k: 90000 };

                function evaluate(s) {
                    let score = 0;
                    for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
                        let p = s[r][c]; if(!p) continue;
                        let t = p.toLowerCase();
                        let v = pieceValues[t] || 0;
                        score += isBlack(p) ? v : -v;
                    }
                    return score;
                }

                function isValidRaw(s, fr, fc, tr, tc) {
                    if(fr===tr && fc===tc) return false; let p=s[fr][fc], target=s[tr][tc];
                    if(target && isWhite(p)===isWhite(target)) return false;
                    let dr=tr-fr, dc=tc-fc, t=p.toLowerCase();
                    const path=()=>{let sR=dr===0?0:dr/Math.abs(dr), sC=dc===0?0:dc/Math.abs(dc), cR=fr+sR, cC=fc+sC; while(cR!==tr||cC!==tc){if(s[cR][cC]!=='') return false; cR+=sR; cC+=sC;} return true;};
                    if(t==='p'){let d=isWhite(p)?-1:1; if(dc===0 && dr===d && target==='') return true; if(dc===0 && dr===d*2 && (fr===6||fr===1) && target==='' && s[fr+d][fc]==='') return true; if(Math.abs(dc)===1 && dr===d && target!=='') return true; return false;}
                    if(t==='r') return (dr===0||dc===0) && path(); if(t==='b') return Math.abs(dr)===Math.abs(dc) && path(); if(t==='q') return (dr===0||dc===0||Math.abs(dr)===Math.abs(dc)) && path();
                    if(t==='k') return Math.abs(dr)<=1 && Math.abs(dc)<=1; if(t==='n') return (Math.abs(dr)===2 && Math.abs(dc)===1) || (Math.abs(dr)===1 && Math.abs(dc)===2); return false;
                }

                function getMoves(s, color) {
                    let m = [];
                    for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
                        if(!s[r][c] || (color==='White' && !isWhite(s[r][c])) || (color==='Black' && !isBlack(s[r][c]))) continue;
                        for(let tr=0; tr<8; tr++) for(let tc=0; tc<8; tc++) if(isValidRaw(s, r, c, tr, tc)) m.push({fr:r, fc:c, tr, tc});
                    }
                    return m;
                }

                function minimax(state, d, alpha, beta, isMax) {
                    if(d === 0) return evaluate(state);
                    let moves = getMoves(state, isMax?'Black':'White');
                    if(isMax) {
                        let v = -Infinity;
                        for(let m of moves) { v = Math.max(v, minimax(sim(state, m), d-1, alpha, beta, false)); alpha = Math.max(alpha, v); if(beta <= alpha) break; }
                        return v;
                    } else {
                        let v = Infinity;
                        for(let m of moves) { v = Math.min(v, minimax(sim(state, m), d-1, alpha, beta, true)); beta = Math.min(beta, v); if(beta <= alpha) break; }
                        return v;
                    }
                }
                function sim(s, m) { let n=s.map(r=>[...r]); n[m.tr][m.tc]=n[m.fr][m.fc]; if(n[m.tr][m.tc]==='p' && m.tr===7) n[m.tr][m.tc]='q'; n[m.fr][m.fc]=''; return n; }

                let moves = getMoves(boardState, 'Black');
                let bestM = null, bestV = -Infinity;
                for (let m of moves) {
                    let v = minimax(sim(boardState, m), depth-1, -Infinity, Infinity, false);
                    if (v > bestV) { bestV = v; bestM = m; }
                }
                self.postMessage(bestM);
            };
        `;

        const boardElement = document.getElementById('board');
        const pieces = { r:'♜', n:'♞', b:'♝', q:'♛', k:'♚', p:'♟', R:'♜', N:'♞', B:'♝', Q:'♛', K:'♚', P:'♟' };
        let boardState, capturedWhite = [], capturedBlack = [], turn = 'White', pending = null, selected = null;
        let movedStatus = { wK: false, wR1: false, wR2: false, bK: false, bR1: false, bR2: false };
        const ai = new Worker(URL.createObjectURL(new Blob([workerCode], { type: 'application/javascript' })));

        function resetGameData() {
            boardState = [['r','n','b','q','k','b','n','r'],['p','p','p','p','p','p','p','p'],['','','','','','','',''],['','','','','','','',''],['','','','','','','',''],['','','','','','','',''],['P','P','P','P','P','P','P','P'],['R','N','B','Q','K','B','N','R']];
            capturedWhite = []; capturedBlack = []; turn = 'White'; 
            movedStatus = { wK: false, wR1: false, wR2: false, bK: false, bR1: false, bR2: false };
            render();
        }

        ai.onmessage = (e) => {
            const m = e.data; document.getElementById('ai-loader').style.display = 'none';
            if (m) {
                // AI 캐슬링 체크 (간략)
                if(boardState[m.fr][m.fc]==='k' && Math.abs(m.fc-m.tc)===2) {
                    if(m.tc===6) { boardState[0][5]='r'; boardState[0][7]=''; }
                    if(m.tc===2) { boardState[0][3]='r'; boardState[0][0]=''; }
                }
                if (boardState[m.tr][m.tc]) capturedBlack.push(boardState[m.tr][m.tc]);
                boardState[m.tr][m.tc] = boardState[m.fr][m.fc];
                if(boardState[m.tr][m.tc]==='p' && m.tr===7) boardState[m.tr][m.tc]='q'; // AI는 무조건 퀸
                boardState[m.fr][m.fc] = '';
                turn = 'White'; render(); checkStatus('White');
            }
        };

        function checkStatus(color) {
            const inCheck = isCheck(boardState, color);
            document.getElementById('status').innerText = inCheck ? "⚠️ CHECK!" : (color==='White' ? "당신의 차례" : "AI 분석 중...");
        }

        function isCheck(s, color) {
            let kPos = null; for(let r=0; r<8; r++) for(let c=0; c<8; c++) if(s[r][c] === (color==='White'?'K':'k')) kPos = {r,c};
            if(!kPos) return false;
            for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
                let p = s[r][c]; if(!p) continue;
                if((color==='White' && p===p.toLowerCase()) || (color==='Black' && p===p.toUpperCase()))
                    if(isValidRaw(s, r, c, kPos.r, kPos.c)) return true;
            }
            return false;
        }

        function isValidRaw(s, fr, fc, tr, tc, ignoreCastling = false) {
            if(fr===tr && fc===tc) return false; let p=s[fr][fc], target=s[tr][tc];
            if(target && (p===p.toUpperCase())===(target===target.toUpperCase())) return false;
            let dr=tr-fr, dc=tc-fc, t=p.toLowerCase();
            const path=()=>{let sR=dr===0?0:dr/Math.abs(dr), sC=dc===0?0:dc/Math.abs(dc), cR=fr+sR, cC=fc+sC; while(cR!==tr||cC!==tc){if(s[cR][cC]!=='') return false; cR+=sR; cC+=sC;} return true;};
            
            if(t==='p'){
                let d=(p===p.toUpperCase())?-1:1;
                if(dc===0 && dr===d && target==='') return true;
                if(dc===0 && dr===d*2 && (fr===6||fr===1) && target==='' && s[fr+d][fc]==='') return true;
                if(Math.abs(dc)===1 && dr===d && target!=='') return true;
                return false;
            }
            if(t==='r') return (dr===0||dc===0) && path();
            if(t==='b') return Math.abs(dr)===Math.abs(dc) && path();
            if(t==='q') return (dr===0||dc===0||Math.abs(dr)===Math.abs(dc)) && path();
            if(t==='k') {
                if(Math.abs(dr)<=1 && Math.abs(dc)<=1) return true;
                // 캐슬링 로직
                if(!ignoreCastling && dr===0 && Math.abs(dc)===2) {
                    if(isCheck(s, p===p.toUpperCase()?'White':'Black')) return false;
                    if(p==='K' && !movedStatus.wK) {
                        if(tc===6 && !movedStatus.wR2 && s[7][5]==='' && s[7][6]==='') return true;
                        if(tc===2 && !movedStatus.wR1 && s[7][1]==='' && s[7][2]==='' && s[7][3]==='') return true;
                    }
                    if(p==='k' && !movedStatus.bK) {
                        if(tc===6 && !movedStatus.bR2 && s[0][5]==='' && s[0][6]==='') return true;
                        if(tc===2 && !movedStatus.bR1 && s[0][1]==='' && s[0][2]==='' && s[0][3]==='') return true;
                    }
                }
                return false;
            }
            if(t==='n') return (Math.abs(dr)===2 && Math.abs(dc)===1) || (Math.abs(dr)===1 && Math.abs(dc)===2);
            return false;
        }

        function render() {
            boardElement.innerHTML = '<div id="promotion-overlay"></div>';
            const inCheck = isCheck(boardState, turn);
            for (let r=0; r<8; r++) for (let c=0; c<8; c++) {
                const s = document.createElement('div'); s.className = `square ${(r+c)%2===0?'light':'dark'}`;
                if (selected?.r === r && selected?.c === c) s.classList.add('selected');
                if (pending) { if (pending.fr===r && pending.fc===c) s.classList.add('origin'); if (pending.tr===r && pending.tc===c) s.classList.add('pending'); }
                const p = boardState[r][c]; 
                if (p === (turn==='White'?'K':'k') && inCheck) s.classList.add('check');
                if (p) { s.textContent = pieces[p]; s.classList.add(p === p.toUpperCase() ? 'white-piece' : 'black-piece'); }
                s.onclick = () => handleSquareClick(r, c);
                boardElement.appendChild(s);
            }
            document.getElementById('white-captured').innerHTML = "내가 잡음: " + capturedWhite.map(p => pieces[p]).join('');
            document.getElementById('black-captured').innerHTML = "AI 잡음: " + capturedBlack.map(p => pieces[p]).join('');
        }

        function handleSquareClick(r, c) {
            if(turn==='Black'||pending) return; const p=boardState[r][c];
            if(selected) {
                if(selected.r===r && selected.c===c) selected=null;
                else if(p && p===p.toUpperCase()) selected={r,c};
                else if(isValidRaw(boardState, selected.r, selected.c, r, c)) {
                    let ns = boardState.map(row=>[...row]); 
                    let movingPiece = boardState[selected.r][selected.c];
                    
                    // 캐슬링 처리
                    let isCastling = movingPiece==='K' && Math.abs(selected.c - c) === 2;
                    if(isCastling) {
                        if(c===6) { ns[7][5]='R'; ns[7][7]=''; }
                        if(c===2) { ns[7][3]='R'; ns[7][0]=''; }
                    }

                    ns[r][c]=movingPiece; ns[selected.r][selected.c]='';
                    if(isCheck(ns, 'White')) { alert("⚠️ 왕이 위험합니다!"); return; }
                    
                    pending={ fr:selected.r, fc:selected.c, tr:r, tc:c, p:movingPiece, cap:boardState[r][c], castling: isCastling };
                    
                    // 폰 프로모션 체크
                    if(movingPiece==='P' && r===0) {
                        showPromotionUI();
                    } else {
                        boardState = ns;
                        selected=null;
                        document.getElementById('btn-confirm').style.display='block'; 
                        document.getElementById('btn-cancel').style.display='block';
                    }
                }
            } else if(p && p===p.toUpperCase()) selected={r,c};
            render();
        }

        function showPromotionUI() {
            const overlay = document.getElementById('promotion-overlay');
            overlay.style.display = 'flex';
            overlay.innerHTML = '';
            ['Q','R','B','N'].forEach(type => {
                const btn = document.createElement('div');
                btn.className = 'promo-choice';
                btn.textContent = pieces[type];
                btn.onclick = (e) => {
                    e.stopPropagation();
                    pending.p = type;
                    boardState[pending.tr][pending.tc] = type;
                    boardState[pending.fr][pending.fc] = '';
                    overlay.style.display = 'none';
                    document.getElementById('btn-confirm').style.display='block'; 
                    document.getElementById('btn-cancel').style.display='block';
                    render();
                };
                overlay.appendChild(btn);
            });
        }

        window.confirmMove = () => {
            if (pending.cap) capturedWhite.push(pending.cap);
            
            // 이동 상태 업데이트 (캐슬링용)
            if(pending.p==='K') movedStatus.wK = true;
            if(pending.fr===7 && pending.fc===0) movedStatus.wR1 = true;
            if(pending.fr===7 && pending.fc===7) movedStatus.wR2 = true;

            pending = null; turn = 'Black'; render();
            document.getElementById('btn-confirm').style.display = 'none'; document.getElementById('btn-cancel').style.display = 'none';
            document.getElementById('status').innerText = "AI 분석 중..."; document.getElementById('ai-loader').style.display = 'block';
            ai.postMessage({ boardState, depth: 3 });
        };

        window.cancelMove = () => { location.reload(); }; // 취소 시 상태 복구가 복잡하므로 단순 새로고침 처리
        window.resetGame = () => { if(confirm("초기화하시겠습니까?")) resetGameData(); };
        
        resetGameData();
    </script>
</body>
</html>
