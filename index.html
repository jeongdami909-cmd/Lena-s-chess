<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI ì²´ìŠ¤ ì—°ìŠµì¥ - v5</title>
    <style>
        body {
            display: flex; flex-direction: column; align-items: center;
            font-family: -apple-system, sans-serif; background-color: #fcf9f2;
            margin: 0; padding: 20px 10px; touch-action: manipulation;
        }
        #board {
            display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr);
            width: 95vw; max-width: 500px; height: 95vw; max-height: 500px;
            border: 5px solid #3d2b1f; box-shadow: 0 10px 25px rgba(0,0,0,0.2);
        }
        .square {
            display: flex; justify-content: center; align-items: center;
            font-size: calc(95vw / 10); cursor: pointer; user-select: none;
            -webkit-tap-highlight-color: transparent;
        }
        @media (min-width: 500px) { .square { font-size: 50px; } }
        /* ë”°ëœ»í•œ ê°ˆìƒ‰ í…Œë§ˆ */
        .light { background-color: #fceecf; } /* ë¶€ë“œëŸ¬ìš´ ë…¸ë€ìƒ‰ */
        .dark { background-color: #b58863; color: #ffffff; } /* ì¤‘ê°„ ê°ˆìƒ‰ */
        .selected { background-color: #7b9a58 !important; }
        .pending { background-color: #e5c158 !important; }
        /* ê¸°ë¬¼ ìƒ‰ìƒ êµ¬ë¶„ ëª…í™•í•˜ê²Œ */
        .black-piece { color: #000000; }
        .white-piece { color: #ffffff; }
        #controls { margin-top: 25px; width: 95vw; max-width: 500px; display: flex; gap: 10px; }
        button { flex: 1; padding: 15px 0; font-size: 18px; font-weight: bold; border: none; border-radius: 12px; color: white; }
        #btn-confirm { background-color: #4CAF50; display: none; }
        #btn-cancel { background-color: #f44336; display: none; }
        #status { margin-bottom: 15px; font-size: 20px; font-weight: bold; color: #3d2b1f; }
    </style>
</head>
<body>

    <div id="status">ë‹¹ì‹ ì˜ ì°¨ë¡€ (ë°±)</div>
    <div id="board"></div>

    <div id="controls">
        <button id="btn-cancel" onclick="cancelMove()">ì·¨ì†Œ</button>
        <button id="btn-confirm" onclick="confirmMove()">ì´ë™ í™•ì •</button>
    </div>

    <script>
        window.onload = function() {
            const boardElement = document.getElementById('board');
            const pieces = { r:'â™œ', n:'â™', b:'â™', q:'â™›', k:'â™š', p:'â™Ÿ', R:'â™–', N:'â™˜', B:'â™—', Q:'â™•', K:'â™”', P:'â™™' };
            const pieceValues = { p: 10, n: 30, b: 30, r: 50, q: 90, k: 900 };

            let boardState = [
                ['r', 'n', 'b', 'q', 'k', 'b', 'n', 'r'],
                ['p', 'p', 'p', 'p', 'p', 'p', 'p', 'p'],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['', '', '', '', '', '', '', ''],
                ['P', 'P', 'P', 'P', 'P', 'P', 'P', 'P'],
                ['R', 'N', 'B', 'Q', 'K', 'B', 'N', 'R']
            ];

            let turn = 'White';
            let selected = null;
            let pendingMove = null;

            const isWhite = (p) => p && p === p.toUpperCase();
            const isBlack = (p) => p && p === p.toLowerCase();

            function renderBoard() {
                boardElement.innerHTML = '';
                for (let r = 0; r < 8; r++) {
                    for (let c = 0; c < 8; c++) {
                        const square = document.createElement('div');
                        square.className = `square ${(r + c) % 2 === 0 ? 'light' : 'dark'}`;
                        if (selected && selected.r === r && selected.c === c) square.classList.add('selected');
                        if (pendingMove && pendingMove.toR === r && pendingMove.toC === c) square.classList.add('pending');
                        const piece = boardState[r][c];
                        if (piece) {
                            square.textContent = pieces[piece];
                            square.classList.add(isWhite(piece) ? 'white-piece' : 'black-piece');
                        }
                        square.onclick = () => handleSquareClick(r, c);
                        boardElement.appendChild(square);
                    }
                }
            }

            function handleSquareClick(r, c) {
                if (turn === 'Black' || pendingMove) return;
                const piece = boardState[r][c];
                if (selected) {
                    if (selected.r === r && selected.c === c) { selected = null; renderBoard(); }
                    else if (isWhite(piece)) { selected = {r, c}; renderBoard(); }
                    else if (isValidMove(selected.r, selected.c, r, c)) {
                        applyTemporaryMove(selected.r, selected.c, r, c);
                    }
                } else if (isWhite(piece)) { selected = {r, c}; renderBoard(); }
            }

            function applyTemporaryMove(fr, fc, tr, tc) {
                pendingMove = { fromR: fr, fromC: fc, toR: tr, toC: tc, piece: boardState[fr][fc], captured: boardState[tr][tc] };
                boardState[tr][tc] = pendingMove.piece;
                boardState[fr][fc] = '';
                selected = null;
                document.getElementById('btn-confirm').style.display = 'block';
                document.getElementById('btn-cancel').style.display = 'block';
                renderBoard();
            }

            // ğŸ¤– AIì˜ ë‡Œ (ê°€ì¥ ê°€ì¹˜ ë†’ì€ ê¸°ë¬¼ ì¡ê¸°)
            function makeAIMove() {
                document.getElementById('status').innerText = "AIê°€ ìƒê° ì¤‘...";
                setTimeout(() => {
                    let allMoves = [];
                    for (let r = 0; r < 8; r++) {
                        for (let c = 0; c < 8; c++) {
                            if (isBlack(boardState[r][c])) {
                                for (let tr = 0; tr < 8; tr++) {
                                    for (let tc = 0; tc < 8; tc++) {
                                        if (isValidMove(r, c, tr, tc)) {
                                            let score = 0;
                                            let target = boardState[tr][tc];
                                            if (target) score = pieceValues[target.toLowerCase()];
                                            allMoves.push({fr: r, fc: c, tr: tr, tc: tc, score: score});
                                        }
                                    }
                                }
                            }
                        }
                    }
                    if (allMoves.length > 0) {
                        allMoves.sort((a, b) => b.score - a.score || Math.random() - 0.5);
                        const bestMove = allMoves[0];
                        boardState[bestMove.tr][bestMove.tc] = boardState[bestMove.fr][bestMove.fc];
                        boardState[bestMove.fr][bestMove.fc] = '';
                        turn = 'White';
                        document.getElementById('status').innerText = "ë‹¹ì‹ ì˜ ì°¨ë¡€ (ë°±)";
                        renderBoard();
                    }
                }, 600);
            }

            window.confirmMove = function() {
                pendingMove = null;
                turn = 'Black';
                document.getElementById('btn-confirm').style.display = 'none';
                document.getElementById('btn-cancel').style.display = 'none';
                renderBoard();
                makeAIMove(); // í„´ ì¢…ë£Œ ì‹œ AI í˜¸ì¶œ!
            }

            window.cancelMove = function() {
                boardState[pendingMove.fromR][pendingMove.fromC] = pendingMove.piece;
                boardState[pendingMove.toR][pendingMove.toC] = pendingMove.captured;
                pendingMove = null;
                document.getElementById('btn-confirm').style.display = 'none';
                document.getElementById('btn-cancel').style.display = 'none';
                renderBoard();
            }

            function isValidMove(fr, fc, tr, tc) {
                const piece = boardState[fr][fc];
                const target = boardState[tr][tc];
                const dr = tr - fr; const dc = tc - fc;
                const absDr = Math.abs(dr); const absDc = Math.abs(dc);
                if (target && ((isWhite(piece) && isWhite(target)) || (isBlack(piece) && isBlack(target)))) return false;
                const isPathClear = () => {
                    let stepR = dr === 0 ? 0 : dr / absDr;
                    let stepC = dc === 0 ? 0 : dc / absDc;
                    let curR = fr + stepR; let curC = fc + stepC;
                    while (curR !== tr || curC !== tc) {
                        if (boardState[curR][curC] !== '') return false;
                        curR += stepR; curC += stepC;
                    }
                    return true;
                };
                const type = piece.toLowerCase();
                if (type === 'p') {
                    const dir = isWhite(piece) ? -1 : 1;
                    if (dc === 0 && dr === dir && target === '') return true;
                    if (dc === 0 && dr === dir * 2 && (fr === 6 || fr === 1) && target === '' && boardState[fr+dir][fc] === '') return true;
                    if (Math.abs(dc) === 1 && dr === dir && target !== '') return true;
                    return false;
                }
                if (type === 'r') return (dr === 0 || dc === 0) && isPathClear();
                if (type === 'b') return absDr === absDc && isPathClear();
                if (type === 'q') return (dr === 0 || dc === 0 || absDr === absDc) && isPathClear();
                if (type === 'k') return absDr <= 1 && absDc <= 1;
                if (type === 'n') return (absDr === 2 && absDc === 1) || (absDr === 1 && absDc === 2);
                return false;
            }
            renderBoard();
        };
    </script>
</body>
</html>
