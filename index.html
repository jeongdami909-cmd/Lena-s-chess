<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>ÌîÑÎ°ú AI Ï≤¥Ïä§ - v44 Ultra</title>
    <style>
        * { box-sizing: border-box; -webkit-tap-highlight-color: transparent; }
        html, body { height: 100%; margin: 0; padding: 0; overflow: hidden; background-color: #f7f3eb; }
        body { display: flex; flex-direction: column; align-items: center; font-family: -apple-system, sans-serif; padding: 5px; }
        .app-wrapper { width: 100%; max-width: 400px; height: 100%; display: flex; flex-direction: column; justify-content: space-between; }
        
        #ui-header { height: 55px; display: flex; flex-direction: column; justify-content: center; align-items: center; text-align: center; background: white; border-radius: 8px; margin-bottom: 2px; box-shadow: 0 1px 2px rgba(0,0,0,0.1); }
        #status { font-size: 13px; font-weight: 800; color: #2c3e50; }
        #last-move { font-size: 10px; color: #7f8c8d; font-weight: 600; }
        #ai-loader { visibility: hidden; width: 60%; height: 2px; background: #eee; overflow: hidden; margin-top: 2px; }
        .thinking-bar { width: 30%; height: 100%; background: #3498db; animation: move 1s infinite linear; }
        @keyframes move { from { margin-left: -30%; } to { margin-left: 100%; } }

        /* Î≥¥Îìú ÏûîÏÉÅ Î∞©ÏßÄ Î∞è ÏÑ†Î™ÖÌïú ÌïòÏù¥ÎùºÏù¥Ìä∏ */
        #board { display: grid; grid-template-columns: repeat(8, 1fr); grid-template-rows: repeat(8, 1fr); width: 100%; aspect-ratio: 1 / 1; border: 3px solid #3d2b1f; background-color: #3d2b1f; position: relative; overflow: hidden; }
        .square { display: flex; justify-content: center; align-items: center; font-size: 8.5vw; cursor: pointer; position: relative; z-index: 1; }
        @media (min-width: 400px) { .square { font-size: 36px; } }
        
        .light { background-color: #f1d9b5; } .dark { background-color: #b58863; }
        
        /* ÏñºÎ£© Î∞©ÏßÄÏö© RGBA ÌïòÏù¥ÎùºÏù¥Ìä∏ (Opacity Ï†úÍ±∞) */
        .selected { background-color: #bac466 !important; }
        .pending { background-color: #fce38a !important; } /* Ïù¥Ï†Ñ ÏûîÏÉÅ Î≤ÑÍ∑∏ ÏàòÏ†ï */
        .origin { background-color: #f6d167 !important; }
        .check { background: radial-gradient(circle, #ff7675 40%, transparent 80%) !important; }

        .black-piece { color: #000; filter: drop-shadow(0 1px 1px #fff); z-index: 2; }
        .white-piece { color: #fff; filter: drop-shadow(0 2px 3px rgba(0,0,0,0.5)); z-index: 2; }
        
        .captured-area { width: 100%; height: 25px; display: flex; align-items: center; gap: 2px; padding: 0 8px; border-radius: 4px; font-size: 10px; font-weight: bold; border: 1px solid #ddd; overflow-x: auto; white-space: nowrap; }
        #black-captured { background: #fceaea; color: #c0392b; margin-bottom: 1px; }
        #white-captured { background: #eafaf1; color: #27ae60; margin-top: 1px; }
        
        #stats-panel { background: #fff; border-radius: 6px; padding: 3px 6px; font-size: 9px; color: #34495e; box-shadow: 0 1px 2px rgba(0,0,0,0.05); margin: 1px 0; }
        .stats-grid { display: grid; grid-template-columns: 1fr 1fr; gap: 4px; }
        .stats-row { display: flex; justify-content: space-between; border-bottom: 1px solid #f1f2f6; padding: 1px 0; }
        
        .ui-row { display: flex; gap: 3px; width: 100%; margin-bottom: 1px; }
        button { flex: 1; padding: 8px 0; font-size: 11px; font-weight: bold; border: none; border-radius: 5px; cursor: pointer; color: white; transition: transform 0.1s; }
        button:active { transform: scale(0.97); }
        #btn-confirm { background-color: #27ae60; display: none; }
        #btn-cancel { background-color: #e74c3c; display: none; }
        #btn-reset { background-color: #7f8c8d; }
        .castle-btn { background-color: #8e44ad; display: none; }

        #promotion-overlay { display: none; position: absolute; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.85); z-index: 100; justify-content: center; align-items: center; gap: 8px; }
        .promo-choice { width: 45px; height: 45px; background: #fff; border-radius: 6px; display: flex; justify-content: center; align-items: center; font-size: 28px; cursor: pointer; }
    </style>
</head>
<body>
    <div class="app-wrapper">
        <div id="ui-header">
            <div id="status">Ultra AI Edition v44</div>
            <div id="last-move">Ï§ÄÎπÑ ÏôÑÎ£å</div>
            <div id="ai-loader"><div class="thinking-bar"></div></div>
        </div>

        <div class="captured-area" id="black-captured">AI ÌöçÎìù: </div>
        <div id="board"><div id="promotion-overlay"></div></div>
        <div class="captured-area" id="white-captured">ÎÇ¥Í∞Ä ÌöçÎìù: </div>
        
        <div id="stats-panel">
            <div class="stats-grid">
                <div id="stats-white"></div>
                <div id="stats-black"></div>
            </div>
        </div>

        <div class="ui-row">
            <button id="btn-castle-king" class="castle-btn" onclick="tryCastle('king')">ÌÇπÏÇ¨Ïù¥Îìú Ï∫êÏä¨ üè∞</button>
            <button id="btn-castle-queen" class="castle-btn" onclick="tryCastle('queen')">ÌÄ∏ÏÇ¨Ïù¥Îìú Ï∫êÏä¨ üè∞</button>
        </div>

        <div class="ui-row">
            <button id="btn-reset" onclick="resetGame()">ÏÉà Í≤åÏûÑ</button>
            <button id="btn-cancel" onclick="cancelMove()">Ïù¥Îèô Ï∑®ÏÜå</button>
            <button id="btn-confirm" onclick="confirmMove()">Ïù¥Îèô ÌôïÏ†ï</button>
        </div>
    </div>

    <script>
        // --- Grandmaster Level AI Worker (PST ÏµúÏ†ÅÌôî Î∞è ÏñºÎ£© Î∞©ÏßÄ Î°úÏßÅ Ìè¨Ìï®) ---
        const workerCode = `
            self.onmessage = function(e) {
                const { boardState, depth } = e.data;
                const pVals = { p:100, n:330, b:340, r:510, q:920, k:20000 };
                
                // Ï†ÑÏà† Îç∞Ïù¥ÌÑ∞ Í∏∞Î∞ò PST ÌÖåÏù¥Î∏î (Í∏∞ÎèôÏÑ± Î∞è Ï§ëÏïô Ï†êÏú† Í∞ïÌôî)
                const pst = {
                    p: [0,0,0,0,0,0,0,0, 50,50,50,50,50,50,50,50, 10,10,20,35,35,20,10,10, 5,5,10,28,28,10,5,5, 0,0,0,22,22,0,0,0, 5,-5,-10,0,0,-10,-5,5, 5,10,10,-20,-20,10,10,5, 0,0,0,0,0,0,0,0],
                    n: [-50,-40,-30,-30,-30,-30,-40,-50, -40,-20,0,5,5,0,-20,-40, -30,5,15,20,20,15,5,-30, -30,0,20,25,25,20,0,-30, -30,5,20,25,25,20,5,-30, -30,0,15,20,20,15,0,-30, -40,-20,0,5,5,0,-20,-40, -50,-40,-30,-30,-30,-30,-40,-50],
                    b: [-20,-10,-10,-10,-10,-10,-10,-20, -10,5,0,0,0,0,5,-10, -10,10,10,10,10,10,10,-10, -10,0,10,15,15,10,0,-10, -10,5,5,15,15,5,5,-10, -10,0,5,10,10,5,0,-10, -10,0,0,0,0,0,0,-10, -20,-10,-10,-10,-10,-10,-10,-20]
                };

                function evaluate(s) {
                    let total = 0;
                    const bMoves = getValidMoves(s, false).length;
                    const wMoves = getValidMoves(s, true).length;
                    for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
                        let p = s[r][c]; if(!p) continue;
                        let t = p.toLowerCase();
                        let val = pVals[t] + (pst[t] ? (p===t ? pst[t][r*8+c] : pst[t][(7-r)*8+c]) : 0);
                        total += (p === t) ? val : -val;
                    }
                    total += (bMoves - wMoves) * 12; // ÏßÄÎä• Ìñ•ÏÉÅÏùÑ ÏúÑÌïú Í∞ÄÎèôÏÑ± ÌèâÍ∞Ä Í∞ïÌôî
                    return total;
                }

                function getValidMoves(s, isWhite) {
                    const moves = [];
                    for(let r=0; r<8; r++) for(let c=0; c<8; c++) {
                        let p = s[r][c]; if(!p || (isWhite ? p!==p.toUpperCase() : p!==p.toLowerCase())) continue;
                        for(let tr=0; tr<8; tr++) for(let tc=0; tc<8; tc++) if(isValid(s, r, c, tr, tc)) moves.push({fr:r, fc:c, tr, tc});
                    }
                    return moves;
                }

                function isValid(s, fr, fc, tr, tc) {
                    if(fr===tr && fc===tc) return false;
                    let p=s[fr][fc]; let target=s[tr][tc]; if(target && (p===p.toUpperCase())===(target===target.toUpperCase())) return false;
                    let dr=tr-fr, dc=tc-fc, t=p.toLowerCase();
                    const path=()=>{let sR=dr===0?0:dr/Math.abs(dr), sC=dc===0?0:dc/Math.abs(dc), cR=fr+sR, cC=fc+sC; while(cR!==tr||cC!==tc){if(s[cR][cC]!=='') return false; cR+=sR; cC+=sC;} return true;};
                    if(t==='p'){ let d=(p===p.toUpperCase())?-1:1; if(dc===0 && dr===d && target==='') return true; if(dc===0 && dr===d*2 && (fr===6||fr===1) && target==='' && s[fr+d][fc]==='') return true; if(Math.abs(dc)===1 && dr===d && target!=='') return true; return false; }
                    if(t==='r') return (dr===0||dc===0) && path(); if(t==='b') return Math.abs(dr)===Math.abs(dc) && path(); if(t==='q') return (dr===0||dc===0||Math.abs(dr)===Math.abs(dc)) && path();
                    if(t==='n') return (Math.abs(dr)===2 && Math.abs(dc)===1) || (Math.abs(dr)===1 && Math.abs(dc)===2);
                    if(t==='k') return Math.abs(dr)<=1 && Math.abs(dc)<=1; return false;
                }

                function minimax(s, d, alpha, beta, isMax) {
                    if(d===0) return evaluate(s);
                    let moves = getValidMoves(s, !isMax);
                    if(isMax) {
                        let v = -Infinity;
                        for(let m of moves) { let ns = s.map(r=>[...r]); ns[m.tr][m.tc]=ns[m.fr][m.fc]; ns[m.fr][m.fc]=''; v = Math.max(v, minimax(ns, d-1, alpha, beta, false)); alpha = Math.max(alpha, v); if(beta <= alpha) break; }
                        return v === -Infinity ? -50000 : v;
                    } else {
                        let v = Infinity;
                        for(let m of moves) { let ns = s.map(r=>[...r]); ns[m.tr][m.tc]=ns[m.fr][m.fc]; ns[m.fr][m.fc]=''; v = Math.min(v, minimax(ns, d-1, alpha, beta, true)); beta = Math.min(beta, v); if(beta <= alpha) break; }
                        return v === Infinity ? 50000 : v;
                    }
                }

                let possible = getValidMoves(boardState, false);
                possible.sort((a,b) => (boardState[b.tr][b.tc] ? 1 : 0) - (boardState[a.tr][a.tc] ? 1 : 0));
                let best = null, bestV = -Infinity;
                for(let m of possible) { let ns = boardState.map(r=>[...r]); ns[m.tr][m.tc]=ns[m.fr][m.fc]; ns[m.fr][m.fc]=''; let v = minimax(ns, depth-1, -Infinity, Infinity, false); if(v > bestV) { bestV = v; best = m; } }
                self.postMessage(best);
            };
        `;

        const pieces = { r:'‚ôú', n:'‚ôû', b:'‚ôù', q:'‚ôõ', k:'‚ôö', p:'‚ôü', R:'‚ôú', N:'‚ôû', B:'‚ôù', Q:'‚ôõ', K:'‚ôö', P:'‚ôü' };
        let boardState, capturedWhite, capturedBlack, turn, movedStatus, pending, selected, lastState;
        let moveStats = { White: { P:0, N:0, B:0, R:0, Q:0, K:0 }, Black: { p:0, n:0, b:0, r:0, q:0, k:0 } };
        const ai = new Worker(URL.createObjectURL(new Blob([workerCode], { type: 'application/javascript' })));
        const getCoord = (r, c) => String.fromCharCode(97 + c) + (8 - r);

        function calcDist(fr, fc, tr, tc, piece) { if (piece.toLowerCase() === 'n') return 3; return Math.max(Math.abs(tr - fr), Math.abs(tc - fc)); }
        function saveGame() { localStorage.setItem('chess_v44_save', JSON.stringify({ boardState, capturedWhite, capturedBlack, turn, movedStatus, moveStats })); }

        function loadGame() {
            const saved = localStorage.getItem('chess_v44_save');
            if (saved) {
                const d = JSON.parse(saved); boardState = d.boardState; capturedWhite = d.capturedWhite;
                capturedBlack = d.capturedBlack; turn = d.turn; movedStatus = d.movedStatus; moveStats = d.moveStats || moveStats;
            } else { resetGameData(); }
            render();
        }

        function resetGameData() {
            boardState = [['r','n','b','q','k','b','n','r'],['p','p','p','p','p','p','p','p'],['','','','','','','',''],['','','','','','','',''],['','','','','','','',''],['','','','','','','',''],['P','P','P','P','P','P','P','P'],['R','N','B','Q','K','B','N','R']];
            capturedWhite = []; capturedBlack = []; turn = 'White';
            movedStatus = { wK: false, wR1: false, wR2: false, bK: false, bR1: false, bR2: false };
            moveStats = { White: { P:0, N:0, B:0, R:0, Q:0, K:0 }, Black: { p:0, n:0, b:0, r:0, q:0, k:0 } };
            document.getElementById('last-move').innerText = "Ï§ÄÎπÑ ÏôÑÎ£å"; saveGame(); render();
        }

        function renderStats() {
            const wPanel = document.getElementById('stats-white'); const bPanel = document.getElementById('stats-black');
            wPanel.innerHTML = "<b>White</b>";
            for(let key in moveStats.White) { wPanel.innerHTML += `<div class="stats-row"><span>${key}</span><span>${moveStats.White[key]}</span></div>`; }
            bPanel.innerHTML = "<b>Black</b>";
            for(let key in moveStats.Black) { bPanel.innerHTML += `<div class="stats-row"><span>${key.toUpperCase()}</span><span>${moveStats.Black[key]}</span></div>`; }
        }

        function render() {
            const board = document.getElementById('board'); board.innerHTML = '<div id="promotion-overlay"></div>';
            const inCheck = isCheck(boardState, turn);
            for (let r=0; r<8; r++) for (let c=0; c<8; c++) {
                const s = document.createElement('div'); s.className = `square ${(r+c)%2===0?'light':'dark'}`;
                const p = boardState[r][c];
                if (selected?.r === r && selected?.c === c) s.classList.add('selected');
                if (pending && ((pending.fr===r && pending.fc===c) || (pending.tr===r && pending.tc===c))) s.classList.add('pending');
                if (p === (turn==='White'?'K':'k') && inCheck) s.classList.add('check');
                if (p) { const span = document.createElement('span'); span.textContent = pieces[p]; span.className = (p === p.toUpperCase() ? 'white-piece' : 'black-piece'); s.appendChild(span); }
                s.onclick = () => handleSquareClick(r, c); board.appendChild(s);
            }
            document.getElementById('white-captured').innerHTML = "ÎÇ¥ ÌöçÎìù: " + capturedWhite.map(p => pieces[p]).join('');
            document.getElementById('black-captured').innerHTML = "AI ÌöçÎìù: " + capturedBlack.map(p => pieces[p]).join('');
            updateCastleButtons(); renderStats();
        }

        function isCheck(s, color) {
            let kChar = color==='White'?'K':'k'; let kr, kc;
            for(let r=0; r<8; r++) for(let c=0; c<8; c++) if(s[r][c]===kChar){kr=r; kc=c;}
            if(kr===undefined) return false;
            for(let i=0; i<8; i++) for(let j=0; j<8; j++){
                let p=s[i][j]; if(!p) continue;
                if((color==='White'?p===p.toLowerCase():p===p.toUpperCase()) && isValidRaw(s, i, j, kr, kc)) return true;
            } return false;
        }

        function isValidRaw(s, fr, fc, tr, tc) {
            if(fr===tr && fc===tc) return false;
            let p=s[fr][fc]; let target=s[tr][tc]; if(target && (p===p.toUpperCase())===(target===target.toUpperCase())) return false;
            let dr=tr-fr, dc=tc-fc, t=p.toLowerCase();
            const path=()=>{let sR=dr===0?0:dr/Math.abs(dr), sC=dc===0?0:dc/Math.abs(dc), cR=fr+sR, cC=fc+sC; while(cR!==tr||cC!==tc){if(s[cR][cC]!=='') return false; cR+=sR; cC+=sC;} return true;};
            if(t==='p'){ let d=(p===p.toUpperCase())?-1:1; if(dc===0 && dr===d && target==='') return true; if(dc===0 && dr===d*2 && (fr===6||fr===1) && target==='' && s[fr+d][fc]==='') return true; if(Math.abs(dc)===1 && dr===d && target!=='') return true; return false; }
            if(t==='r') return (dr===0||dc===0) && path(); if(t==='b') return Math.abs(dr)===Math.abs(dc) && path(); if(t==='q') return (dr===0||dc===0||Math.abs(dr)===Math.abs(dc)) && path();
            if(t==='n') return (Math.abs(dr)===2 && Math.abs(dc)===1) || (Math.abs(dr)===1 && Math.abs(dc)===2);
            if(t==='k') return Math.abs(dr)<=1 && Math.abs(dc)<=1; return false;
        }

        window.tryCastle = (side) => {
            lastState = JSON.parse(JSON.stringify(boardState));
            if(side === 'king') { boardState[7][6]='K'; boardState[7][4]=''; boardState[7][5]='R'; boardState[7][7]=''; pending={type:'castle',side:'king',fr:7,fc:4,tr:7,tc:6,p:'K'}; }
            else { boardState[7][2]='K'; boardState[7][4]=''; boardState[7][3]='R'; boardState[7][0]=''; pending={type:'castle',side:'queen',fr:7,fc:4,tr:7,tc:2,p:'K'}; }
            selected=null; document.getElementById('btn-confirm').style.display='block'; document.getElementById('btn-cancel').style.display='block'; render();
        }

        function handleSquareClick(r, c) {
            if(turn==='Black' || pending) return;
            const p=boardState[r][c];
            if(selected) {
                if(selected.r===r && selected.c===c) selected=null;
                else if(p && p===p.toUpperCase()) selected={r,c};
                else if(isValidRaw(boardState, selected.r, selected.c, r, c)) {
                    lastState = JSON.parse(JSON.stringify(boardState));
                    let movingPiece = boardState[selected.r][selected.c]; let cap = boardState[r][c];
                    boardState[r][c] = movingPiece; boardState[selected.r][selected.c] = '';
                    if(isCheck(boardState, 'White')) { boardState = lastState; alert("‚ö†Ô∏è Ï≤¥ÌÅ¨ ÏúÑÌóò!"); return; }
                    pending = { fr:selected.r, fc:selected.c, tr:r, tc:c, p:movingPiece, cap:cap };
                    selected = null; if(movingPiece==='P' && r===0) showPromotionUI();
                    else { document.getElementById('btn-confirm').style.display='block'; document.getElementById('btn-cancel').style.display='block'; }
                }
            } else if(p && p===p.toUpperCase()) selected={r,c};
            render();
        }

        function showPromotionUI() {
            const overlay = document.getElementById('promotion-overlay'); overlay.style.display = 'flex';
            ['Q','R','B','N'].forEach(type => {
                const b = document.createElement('div'); b.className = 'promo-choice'; b.textContent = pieces[type];
                b.onclick = (e) => { e.stopPropagation(); boardState[pending.tr][pending.tc] = type; pending.p = type; overlay.style.display = 'none'; document.getElementById('btn-confirm').style.display='block'; document.getElementById('btn-cancel').style.display='block'; render(); };
                overlay.appendChild(b);
            });
        }

        function updateCastleButtons() {
            const bk = document.getElementById('btn-castle-king'); const bq = document.getElementById('btn-castle-queen');
            bk.style.display = 'none'; bq.style.display = 'none';
            if(!selected || boardState[selected.r][selected.c] !== 'K' || turn !== 'White' || isCheck(boardState, 'White')) return;
            const isAttacked = (r, c) => { for(let i=0; i<8; i++) for(let j=0; j<8; j++){ let p=boardState[i][j]; if(!p) continue; if(p===p.toLowerCase() && isValidRaw(boardState, i, j, r, c)) return true; } return false; };
            if(!movedStatus.wK && !movedStatus.wR2 && boardState[7][5]==='' && boardState[7][6]==='' && !isAttacked(7, 5)) bk.style.display = 'block';
            if(!movedStatus.wK && !movedStatus.wR1 && boardState[7][1]==='' && boardState[7][2]==='' && boardState[7][3]==='' && !isAttacked(7, 2)) bq.style.display = 'block';
        }

        window.confirmMove = () => {
            if (pending.cap) capturedWhite.push(pending.cap);
            document.getElementById('last-move').innerText = "ÎÇò: " + getCoord(pending.fr, pending.fc) + " ‚ûî " + getCoord(pending.tr, pending.tc);
            const dist = calcDist(pending.fr, pending.fc, pending.tr, pending.tc, pending.p); moveStats.White[pending.p.toUpperCase()] += dist;
            if(pending.p==='K') movedStatus.wK = true;
            if(pending.fr===7 && pending.fc===0) movedStatus.wR1 = true;
            if(pending.fr===7 && pending.fc===7) movedStatus.wR2 = true;
            pending = null; turn = 'Black'; document.getElementById('btn-confirm').style.display = 'none'; document.getElementById('btn-cancel').style.display = 'none';
            saveGame(); render(); document.getElementById('status').innerText = "AI Ïàò ÏùΩÎäî Ï§ë..."; document.getElementById('ai-loader').style.visibility = 'visible';
            ai.postMessage({ boardState, depth: 3 });
        };

        window.cancelMove = () => { if(!pending) return; boardState = lastState; pending = null; document.getElementById('btn-confirm').style.display = 'none'; document.getElementById('btn-cancel').style.display = 'none'; render(); };
        window.resetGame = () => { if(confirm("Ï¥àÍ∏∞ÌôîÌïòÏãúÍ≤†ÏäµÎãàÍπå?")) { localStorage.removeItem('chess_v44_save'); resetGameData(); } };

        ai.onmessage = (e) => {
            const m = e.data; document.getElementById('ai-loader').style.visibility = 'hidden';
            if (m) {
                const piece = boardState[m.fr][m.fc]; const dist = calcDist(m.fr, m.fc, m.tr, m.tc, piece); moveStats.Black[piece.toLowerCase()] += dist;
                document.getElementById('last-move').innerText += " | AI: " + getCoord(m.fr, m.fc) + " ‚ûî " + getCoord(m.tr, m.tc);
                if (boardState[m.tr][m.tc]) capturedBlack.push(boardState[m.tr][m.tc]);
                boardState[m.tr][m.tc] = boardState[m.fr][m.fc];
                if(boardState[m.tr][m.tc]==='p' && m.tr===7) boardState[m.tr][m.tc]='q';
                boardState[m.fr][m.fc] = ''; if(boardState[m.tr][m.tc]==='k') movedStatus.bK = true;
                turn = 'White'; saveGame(); render(); document.getElementById('status').innerText = isCheck(boardState, 'White') ? "‚ö†Ô∏è CHECK!" : "ÎãπÏã†Ïùò Ï∞®Î°ÄÏûÖÎãàÎã§";
            }
        };
        loadGame();
    </script>
</body>
</html>
